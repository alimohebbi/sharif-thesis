\subsection{معیارهای پیش‌بینی خطا}
\label{subsec:metrics}
معیارهای پیش‌بینی خطا نقش مهمی را در ساخت مدل پیش‌بینی ایفا می‌کنند. اکثریت معیارهای پیش‌بینی خطا را می‌توان به دو دسته‌ی  کلی تقسیم کرد: معیارهای کد و معیارهای فرآیند. معیارهای کد می‌توانند به طور مستقیم از کدهای منبع موجود جمع آوری شوند در حالی که معیارهای فرآیند  از اطلاعات تاریخی که در مخازن نرم‌افزاری مختلف آرشیو شده‌اند استخراج می‌گردند. نمونه‌ای از این مخازن نرم‌افزاری سیستم‌های کنترل نسخه و سیستم‌های ردگیری خطا است. معیار‌های فرآیند از نظر هزینه موثرتر از سایر معیارها هستند\cite{arisholm2010systematic}. در برخی از مقالات نیز معیارهای  پیش‌بینی خطا به سه دسته‌ی: معیارهای کد منبع سنتی، معیارهای شئ‌گرایی و معیارهای فرآیند تقسیم شده‌اند\cite{radjenovic2013software}.\\\\
\textbf{معیارهای کد} \\

معیارهای کد تحت عنوان \واژه{معیارهای محصول} نیز شناخته می‌شوند و میزان پیچیدگی کد را می‌سنجند. \واژه{فرض زمینه‌ای} آنها این است که هرچقدر کد پیچیده‌تر باشد خطا‌خیز‌تر است. برای اندازه‌گیری پیچیدگی کد پژوهش‌گران معیار‌های مختلفی را ارائه داده‌اند که در ادامه مهم‌ترین آنها معرفی خواهند شد. 

این معیارها با استفاده از اندازه‌های مطرح شده در جدول \ref{tab:measure} محاسبه می‌شوند. 

\begin{table}[H] 
	\renewcommand*{\arraystretch}{1.5}	
	\centering \caption{اندازه‌های به کارگرفته شده  در معیارهای کد }
	\label{tab:measure}
	\newcolumntype{C}{>{\centering\arraybackslash} m } 
	\begin{tabular}{|C{2cm}|C{2cm}|C{1.5cm}|C{8cm}|}
		
		\hline
		\hline
		نام & نام لاتین & علامت اختصاری & توضیح \\
		\hline
		\hline
		تعداد خطوط کد & 		\lr{Line of Code}  & LOC		& این اندازه را می‌توان به اندازه‌های جزئی‌تر مانند تعداد خطوط توضیح، قابل اجرا، خالی از نوشته تقسیم کرد \\
		\hline
		تعداد عملگرها & \lr{Number of Operators} & 
		\lr{$N_1$}
		& تعداد عملگرهای موجود مانند + ، - ، \& \\
		\hline
		 
		تعداد عملوندها&  \lr{Number of Operands} & 
		\lr{$N_2$}
		& تعداد عملوندهای استفاده شده در کنار عملگرها\\
		\hline
			تعداد عملگرهای متمایز & \lr{Number of Unique Operators} & 
		\lr{$\eta_1$}
		& ---\\
		\hline
		
		تعداد عملوندهای متمایز &  \lr{Number of Unique Operands} & 
		\lr{$\eta_2$}
		& ---\\
		\hline
		
تعداد یال‌ها &   \lr{Number of Edges} &  E &  تعداد یال‌های گراف جریان کنترلی\\
		\hline
		تعداد گره‌ها &    \lr{Number of Nodes} & N & تعداد گره‌ها در گراف جریان کنترلی \\
		\hline
		
		تعداد قطعات متصل &    \lr{Number of Connected Component} & P  & تعداد قطعات متصل به هم در گراف جریان کنترلی
		\\
		\hline
		
	\end{tabular}
\end{table}


\begin{itemize}
	\item \textbf{معیار بزرگی: }
معیارهای \واژه{بزرگی} اندازه‌ی کلی و حجم کد را می‌سنجند. یکی از اندازه‌های برجسته که در محاسبه‌ی این معیارها و گاها خود به تنهایی به کار می‌رود "تعداد خطوط" می‌باشد. اولین بار \نام{آکیاما}{Akiyama}
 \cite{akiyama1971example}  
رابطه‌ی میان خطا و تعداد خطوط را مطرح کرد. \نام{هالستد}{Halstead}
 \cite{halstead1977elements} 
 چندین معیار بزرگی بر اساس  تعداد عملگرها و عملوند‌ها ارائه داده است و در مقاله‌ی \cite{pawade2016exploring} مورد بازنگری قرار گرفته است. معیارهایی که توسط هالستد مطرح شده‌اند در زیر آمده آمده‌اند که با استفاده از اندازه‌های جدول \ref{tab:measure} محاسبه می‌شوند. 
 \begin{latin}
 \baselineskip=1.1cm
Lenght: $N = N_1 + N_2$ \\
Volume: $V = N \times log_2 (\eta_1 + \eta_2)$\\
Difficulty: $D = \eta_1/2 \times N_2/\eta_2$ \\
Effort: $E = D \times V$ \\
Program Time: $T = E/18$ \\
 \end{latin}
 
 
\item \textbf{معیار پیچیدگی حلقوی: }
\نام{مک‌کیب}{McCabe} معیارهای \واژه{پیچیدگی حلقوی}
را پیشنهاد داد که این معیار با استفاده از تعداد گره‌ها، یالها و قطعات متصل در گراف  \واژه{جریان کنترلی} کد منبع محاسبه می‌گردد\cite{mccabe1976complexity}. این معیارها نشان می‌دهند که راه‌های کنترلی به چه میزان پیچیده هستند. باوجود اینکه جز اولین معیارها بوده است همچنان در پیش‌بینی خطا کاربرد دارد \cite{malhotra2014comparative}. این معیار  با استفاده از فرمول زیر محاسبه می‌شود. \\
\begin{latin}
$V(G) = E - N + 2P $
\end{latin}


\item \textbf{معیار مربوط به شئ‌گرایی: }
با ظهور زبان‌های شئ‌گرایی و محبوبیت آنها معیارهای کد  برای این زبان‌ها ارائه شد تا فرآیند توسعه بهبود یابد. نماینده‌ی این معیارها توسط  \نام{چدامبر و کمرر (CK)}{Chidamber and Kemerer  \lr{(CK)} }
 ارائه شده است\cite{chidamber1994metrics}. این معیارها  که در جدول  \ref{tab:ck-metrics} لیست آنها قرار داده شده، با توجه به خصیصه‌های زبان‌های شئ‌گرا مانند وراثت، \واژه{زوجیت}، \واژه{همبستگی} طراحی شده‌اند. بجز معیارهای  \چر{CK}، معیارهای شئ‌گرایی دیگری نیز بر اساس حجم و کمیت کد منبع پیشنهاد داده شده‌اند. مشابه معیارهای \موکد{اندازه}، معیارهای شئ‌گرایی تعداد نمونه‌های یک کلاس و توابع را می‌شمارند. \\
 \begin{table}[H] 
 	\renewcommand*{\arraystretch}{1.5}	
 	\centering \caption{معیارهای CK }
 	\label{tab:ck-metrics}
 	\newcolumntype{C}{>{\centering\arraybackslash} m } 
 	\begin{tabular}{|C{2cm}|C{3cm}|C{8cm}|}
 		
 		\hline
 		\hline
 		نام & توضیح & نحوه‌ی محاسبه \\
 		\hline
 		\hline
 		WMC &
 		تعداد توابع وزن‌دهی شده & وزن دهی بر اساس پیچیدگی هر تابع انجام می‌شود \\
 		\hline
DIT & 
عمق درخت وراثت & حداکثر طول مسیر از نوادگان یک کلاس تا خود کلاس\\
\hline
NOC &
تعداد فرزندان & تعداد نوادگان مستقیم کلاس\\
\hline
CBO & 
زوجیت میان اشیاء کلاس‌ها & تعداد کلاس‌هایی که کلاس مورد نظر با آن زوج شده است. دو کلاس با هم زوجیت دارند اگر یکی از توابع و یا متغیر‌های دیگری استفاده کرده باشد. \\
\hline
RFC &
پاسخ برای یک کلاس & تعداد توابعی که با فراخوانی یک تابع از کلاس احتمال فراخوانی دارند. برابر است با تعداد کل توابع کلاس و توابعی از سایر کلاس‌ها که در آنها فراخوانی می‌شوند. \\
\hline
LCOM & 
کمبود همبستگی میان توابع & تعداد جفت توابعی که متغیر مشترک ندارند منهای جفت توابعی که متغیر مشترک دارند. \\
 		
 		\hline

\end{tabular}
\end{table}

\end{itemize}
\textbf{معیارهای فرآیند} \\

در ادامه  تعدادی از معیارهای فرآیند بررسی می‌شوند که در این دسته شاخص محسوب می‌شوند. در جدول \ref{tab:process-measure} اندازه‌هایی که در محاسبه‌ی معیارهای فرآیند مثال زده شده به کار می‌رود آمده است. 
\begin{table}[H] 
	\renewcommand*{\arraystretch}{1.5}	
	\centering \caption{اندازه‌های به کارگرفته شده  در معیارهای فرآیند }
	\label{tab:process-measure}
	\newcolumntype{C}{>{\centering\arraybackslash} m } 
	\begin{tabular}{|C{2cm}|C{2cm}|C{2.25cm}|C{7.25cm}|}
		
		\hline
		\hline
		نام & نام لاتین & علامت اختصاری & توضیح \\
		\hline
		\hline
		تعداد خطوط تبدیلی &  Churned LOC & --- & تعداد خطوط اضافه شده به علاوه‌ی خطوط تغییر داده شده در دو نسخه‌ی متفاوت از برنامه \\
		\hline
		تعداد فایل‌های تبدیلی &
		\lr{Files Churned} & --- &
		تعداد فایل‌های تغییر یافته در یک قطعه \\
		\hline
		تعداد فایل‌ها &
		\lr{Files Count} & --- &
		تعداد فایل‌های موجود در یک قطعه\\
		\hline
		تجدیدنظر‌ها &
		\lr{Revisions} & --- &
		تعداد تجدید نظرهایی (اصلاح‌ها) که در فایل انجام شده است\\
		\hline 
		بازآرایی & 
		Refactoring & --- & 
		تعداد دفعاتی که یک فایل بازآرایی شده است. در واقع تعداد ثبت‌هایی شمرده می‌شود که در توضیح آنها کلمه‌ی refactor وجود داشته باشد\\
		\hline
		تعداد ایمیل‌ها &
		\lr{Number of Mails} & POP\_NOM &
		 تعداد ایمیل‌هایی که در آنها نام کلاس مورد نظر آورده شده است\\
		 \hline
		 تعداد نخ‌ها &
		 \lr{Number of Threads} & POP\_NOT &
		 تعداد نخ‌هایی که درباره‌ی یک کلاس صحبت می‌کنند \\
		 \hline
		 تعداد نویسندگان &
		 \lr{ Number of Authors}& POP\_NOA &
		 تعداد نویسندگانی که درباره‌ی کلاس مورد نظر صحبت می‌کنند\\
		 \hline
	\end{tabular}
\end{table}

\begin{itemize}
\item \textbf{تغییر تبدیلی نسبی کد: }
\نام{ناگاپان و بال}{Nagappan and Ball} هشت معیار تغییر \واژه[تبدیلی]{تبدیل} نسبی کد را ارائه داده‌اند\cite{nagappan2005use}. دو مثال از این معیارها در زیر آمده است.  در معیار $M_1 $ تعداد تجمعی خطوط اضافه و حذف شده بین دو نسخه از برنامه را می‌شمارد و بر تعداد خطوط برنامه تقسیم می‌کند. معیار دیگر تعداد فایل‌های تغییر یافته از یک قطعه برنامه را بر تعداد  کل فایل‌ها تقسیم می‌کند. 
\begin{latin}
\baselineskip=1.1cm
$M_1 =\mathlarger{\frac{ Churned LOC }{ Total LOC}}$\\
$M_2 =\mathlarger{\frac{ Files Churned}{ Files Count}}$
\end{latin}

\item \textbf{معیارهای تغییر: }
این معیارها  گستره‌ی تغییرات در تاریخچه‌ی ذخیره شده در سامانه‌ی کنترل نسخه را اندازه می‌گیرند. به عنوان مثال تعداد رفع خطاها، تعداد \واژه{بازآرایی کد} و یا تعداد نویسندگان یک فایل را می‌شمارند. \نام{موزر}{Moser} و همکاران 18 معیار تغییر را از مخازن \نام{اکلیپس}{Eclipse} استخراج کردند و یک تحلیل مقایسه‌ای میان معیارهای کد و معیارهای تغییر انجام دادند. آنها به این نتیجه رسیدند که معیارهای تغییر پیش‌بینی کننده‌ی بهتری از معیارهای کد هستند.  به عنوان نمونه دو مورد از ۱۸ معیار مطرح شده برابر اندازه‌های \موکد{تجدیدنظر‌ها} و \موکد{بازآرایی} است.

\item \textbf{معیارهای شهرت: }
 \نام{بکچلی}{Bacchelli} و همکاران معیارهای \واژه{شهرت} را بر اساس تحلیل ایمیل‌های آرشیو شده‌ی نویسندگان ارائه داده‌اند. ایده‌ی اصلی این معیارها این است که یک قطعه‌ی  نرم‌افزاری که در ایمیل‌ها درباره‌ی آن بیشتر صحبت شده است خطاخیزتر می‌باشد\cite{bacchelli2010popular}.  بکچلی پنج معیار شهرت معرفی کرده است.  به عنوان نمونه سه مورد از آنها  برابر است با اندازه‌های \موکد{تعداد ایمیل‌ها، تعداد نخ‌ها و تعداد نویسندگان}. \\
\end{itemize}


\نام{راجنویک}{Radjenovic} و همکاران در پژوهش خود به \واژه{بررسی قاعده‌مند} معیارهای پیش‌بینی خطا در مطالعات پیشین پرداخته‌اند.  طبق این پژوهش در 49\lr{\%} مطالعات از معیارهای شئ‌گرایی، در 27\lr{\%} معیارهای سنتی کد و در 26 \lr{\%} از معیارهای فرآیند استفاده شده است. با توجه به مطالعات بررسی شده دقت پیش‌بینی خطا  با انتخاب معیارهای مختلف، تفاوت قابل توجهی  پیدا می‌کند. معیارهای شئ‌گرایی و فرآیند موفق‌تر از معیارهای سنتی هستند. معیارهای سنتی  پیچیدگی کد، قویا با معیارهای اندازه مانند تعداد خطوط کد همبستگی دارند و این دو توانایی پیش‌بینی خطا دارند اما جز بهترین معیارها نیستند. معیارهای شئ‌گرایی بهتر از اندازه و پیچیدگی عمل می‌کنند و با این که با معیارهای اندازه همبستگی دارند اما ویژگی‌های بیشتری علاوه بر اندازه را دارند. معیارهای ایستای کد همانند اندازه، پیچیدگی و شئ‌گرایی به منظور بررسی یک نسخه از برنامه مفید هستند اما با هر \واژه{تکرار} در فرآیند توسعه‌ی نرم‌افزار دقت پیش‌بینی آنها کاسته می‌شوند و معیارهای فرآیند در چنین شرایطی بهتر عمل می‌کنند.  با این وجود  که  معیارهای فرآیند‌  دارای توانمندی بالقوه‌ای  هستند، اما در تعداد کمتری از پژوهش‌ها مورد استفاده قرار گرفته‌اند\cite{radjenovic2013software}. \\
 
\نام{آسترند}{Ostrand} و همکاران به بررسی این موضوع پرداخته‌اند که آیا اطلاعاتی درباره‌ی اینکه کدام توسعه‌دهنده یک فایل را اصلاح می‌کند قادر است که پیش‌بینی خطا را بهبود بخشد. در پژوهش قبلی آنها\cite{weyuker2008too} مشخص شده بود که تعداد کلی   افراد توسعه‌دهنده در یک فایل می‌تواند در پیش‌بینی خطا تاثیر متوسطی داشته باشد. در  مقاله‌ی \cite{ostrand2010programmer}  تعدادی از متغیرهای کد منبع و فرآیند به همراه معیار مرتبط به توسعه‌دهنده در نظر گرفته شده است.  در این پژوهش مشخص شد  که تعداد خطاهایی که یک توسعه‌دهنده تولید می‌کند ثابت است و با سایر توسعه دهندگان فرق دارد. این تفاوت با  حجم کدی که یک توسعه‌دهنده اصلاح می‌کند مرتبط است و در نتیجه در نظر گرفتن یک نویسنده خاص نمی‌تواند به بهبود پیش‌بینی خطا کمک کند\cite{ostrand2010programmer}. \\

\نام{رحمان و دوانبو}{Rahman and Devanbu} از جنبه‌های مختلف معیارهای فرآیند  را با سایر معیارها مقایسه کرده‌اند\cite{rahman2013and}. نتایج نشان می‌دهد  زمانی که مدل پیش‌بینی بر روی یک نسخه آموزش می‌بیند و در نسخه‌ی بعدی آزمون می‌شود معیارهای کد، مساحت زیر منحنی  قابل قبولی دارند اما مساحت آنها کمتر از معیارهای فرآیند است  و از نظر معیار مساحت زیر نمودار هزینه-اثربخشی ۲۰ درصد 
بهتر از یک مدل تصادفی عمل نمی‌کنند و  به آن معنی است که این معیارها از نظر هزینه چندان  موثر نیستند. همچنین معیارهای کد ایستاتر هستند، ‌یعنی با تغییرات پروژه و تغییر در توزیع خطاها همچنان معیارها بدون تغییر باقی می‌مانند. معیار ایستا تمایل دارد یک فایل را در \واژه[انتشارهای]{انتشار} متوالی همچنان حاوی خطا معرفی کند. معیارهای ایستا به مدل‌های راکد منجر می‌شوند که این مدل‌ها به سمت فایل‌های بزرگ با تراکم خطای کمتر \واژه{جهت‌گیری} دارند. به عنوان مثال حالتی را در نظر بگیرید که در یک پروژه فایل‌های بزرگ و پیچیده‌ای وجود دارد که پس از چندین انتشار خطاهای آنها برطرف می‌شود اما مدل‌هایی که بر اساس معیارهای کد ساخته شده‌اند همچنان این فایل‌ها را به عنوان خطا‌خیز معرفی می‌کنند. از طرف دیگر حالتی را در نظر بگیرید که یک فایل با اندازه و پیچیدگی کم به تازگی به وجود آمده و یا تغییرات فراوان یافته است. مدل‌های مبتنی بر کد به این فایل‌ها توجه چندانی نخواهند کرد در حالیکه که این فایل‌ها مستعد وجود خطا هستند. بدین ترتیب معیارهای فرآیند بهتر از معیارهای کد عمل می‌کنند. \\
معیارهای و اندازه‌های استفاده شده در این مقاله در جدول \ref{tab:process-measure} و \ref{tab:process-metircs} آورده شده‌اند. در ادامه هر یک از معیارها به طور مشروح توضیح داده می‌شوند. 
 
 \begin{table}[H] 
 	\renewcommand*{\arraystretch}{1.5}	
 	\centering \caption{اندازه‌های فرآیند 
 		\cite{rahman2013and}}
 	\label{tab:process-measures}
 	\newcolumntype{C}{>{\centering\arraybackslash} m } 
 	\newcounter{magicrownumbers}
 	\def\rownumber{}
 	\setcounter{magicrownumbers}{0}
 	\begin{tabular}{|@{\makebox[3em][c]{\rownumber\space}} |c|c|}
 		
 		\hline
 		\hline
 		نام اندازه  & توضیح
 		\gdef\rownumber{\stepcounter{magicrownumbers}\arabic{magicrownumbers}} 
 		\\
 		
 		\hline
 		\hline
 		\lr{COMM } & تعداد ثبت در سیستم کنترل نسخه
 		\\
 		\hline
 		\lr{ADEV} & تعداد توسعه‌دهندگان فعال
 		\\ 
 		\hline
 		\lr{DDEV} & تعداد توسعه‌دهندگان متمایز
 		\\ 
		\hline
 		\lr{MINOR} & تعداد مشارکت‌کنندگان جزئی
 		\\ 
 		\hline
		\lr{OEXP} & تجربه‌ی مالک پرونده
 		\\ 
 		\hline
 	\end{tabular}
 \end{table}

 \begin{table}[H] 
	\renewcommand*{\arraystretch}{1.5}	
	\centering \caption{معیارهای فرآیند 
		\cite{rahman2013and}}
	\label{tab:process-metircs}
	\newcolumntype{C}{>{\centering\arraybackslash} m } 

	\def\rownumber{}
	\setcounter{magicrownumbers}{0}
	\begin{tabular}{|@{\makebox[3em][c]{\rownumber\space}} |c|c|}
		
		\hline
		\hline
		نام معیار  & توضیح
		\gdef\rownumber{\stepcounter{magicrownumbers}\arabic{magicrownumbers}} 
		\\
		
		\hline
		\hline
		\lr{ADD} &  مقدار نرمال‌سازی شده‌ی تعداد خطوط اضافه شده
		\\ 
		\hline
		\lr{DEL}  & مقدار نرمال‌سازی شده‌ی تعداد خطوط حذف شده
		\\ 
		\hline
		\lr{OWN} &  درصد خطوطی که مالک پرونده مشارکت کرده
		\\ 
		\hline
		\lr{NCOMM} & تعداد ثبت‌های همسایگان
		\\ 
		\hline
		\lr{NADEV} & تعداد توسعه‌دهندگان فعال همسایگان
		\\ 
		\hline
		\lr{NDDEV} & تعداد توسعه‌دهندگان متمایز همسایگان
		\\ 
		\hline
	
		\lr{AEXP} & تجربه‌ی تمام مشارکت‌کنندگان
		\\ 
		\hline
		
	\end{tabular}
\end{table}




\begin{enumerate}
	\item
	\textbf{تعداد ثبت در سیستم کنترل نسخه:}
	تعداد ثبت‌هایی که در  پرونده‌ی ‌مورد نظر در طول انتشار قبلی تاکنون تغییر کرده است. برای محاسبه ی آن لازم است که تمام ثبت‌های پروژه بین ثبت کنونی و \واژه{انتشار} قبلی بررسی شود و ثبت‌هایی که در آن این پرونده تغییر کرده‌اند شمرده شوند.
	\item
	\textbf{تعداد توسعه‌دهندگان 
		فعال:}
	تعداد توسعه‌دهندگانی که در طول انتشار قبلی تاکنون (زمان ثبت) پرونده را تغییر داده‌اند. لازم است ثبت‌های موجود در باز‌ه‌ی زمانی خواسته شده بررسی شود و آنها که پرونده مورد نظر را تغییر داده‌اند انتخاب شوند. نام کسانی که ثبت را انجام داده‌اند بازیابی شود و تعداد نام‌های متمایز شمرده شود. 
	\item
	\textbf{تعداد توسعه‌دهندگان	متمایز:}
	مشابه معیار قبلی با این تفاوت که در طول انتشار محاسبه نمی‌شود. بلکه از ابتدای پروژه تا زمان ثبت در نظر گرفته می‌شود. 
	\item
	\textbf{تعداد مشارکت‌کنندگان جزئی:}
	مشارکت‌کننده‌ی جزئی کسی است که کمتر از ۵٪ خطوط موجود در پرونده به او تعلق داشته باشد. بدین منظور نویسنده‌ی هر خط مشخص می‌شود. تعداد خطوط هر نویسنده شمرده می‌شود و بر تعداد خطوط پرونده تقسیم می‌شود. سپس تعداد نویسندگانی که کمتر از ۵٪ مشارکت داشته‌اند شمرده می‌شود. 
\item
\textbf{تجربه‌ی مالک پرونده:}
	ابتدا لازم است که نحوه ی محاسبه تجربه را تعریف کنیم. هر چقدر یک فرد تعداد تغییرات بیشتری را در یک پروژه انجام دهد تجربه بیشتری را در آن پروژه دارد و ثبت را می‌توان به ایجاد تغییر تعبیر کرد. برای محاسبه‌ی معیار ابتدا مالک پرونده مشخص می شود. سپس تعداد ثبت‌هایی که مالک پرونده از ابتدای پروژه تا زمان مورد نظر انجام داده، شمرده می شود.
\end{enumerate}

 \begin{table}[H] 
	\renewcommand*{\arraystretch}{1.5}	
	\centering \caption{اندازه‌های فرآیند به کار رفته در ساخت معیارهای فرآیند 
	}
	\label{tab:process-measures2}
	
	\begin{tabular}{|c|c|}
		
		\hline
		\hline
		نام اندازه  & توضیح
		\\
		
		\hline
		\hline
		AddedLines &
		تعداد خطوط اضافه شده به پرونده در طول انتشار
		\\
		\hline
		AddedLinesInProject & 
		تعداد خطوط اضافه شده به پروژه در طول انتشار
		\\ 
		\hline
			DeletedLines &
		تعداد خطوط حذف شده از پرونده در طول انتشار
		\\
		\hline
		DeletedLinesInProject & 
		تعداد خطوط حذف شده از پروژه در طول انتشار
		\\ 
		\hline
		OwnerParticipation & تعداد خطوطی که به مالک پرونده تعلق دارد
		\\
		\hline
		LOC & تعداد خطوط پرونده
		\\
		\hline
	Neighbors & تعداد همسایگان یک پرونده
	\\ \hline
	$NCommit_i$ &
	اندازه‌ی COMM  برای همسایه‌ی i ام
	\\ \hline
	$NActiveDev_i$ & 
اندازه‌ی ADEV برای همسایه‌ی i ام 
	\\ \hline
	$NDistinctDev_i$ &
	اندازه‌ی DDEV برای همسایه‌ی  i ام
	\\ \hline
	$FON_i$ & 
	تعداد دفعات همسایگی  همسایه‌ی i ام\\
	\hline
Part & 
تعداد مشارکت کنند‌گان در یک پرونده 
\\ \hline
	$PCommit_i$ &
	 تعداد ثبت‌‌‌های مشارکت کننده‌ی i ام
	 \\ \hline
	
	
	
		
	\end{tabular}
\end{table}

\begin{enumerate}

	\item
	\textbf{مقدار نرمال‌سازی شده‌ی تعداد خطوط اضافه شده:}
	این معیار تعداد خطوط اضافه شده در یک پرونده را در طول انتشار قبلی می‌شمارد. سپس جهت نرمال سازی آنرا بر تعداد کل خطوط اضافه شده در پروژه در طول انتشار قبلی تقسیم می‌کند. برای بدست آوردن تعداد خطوط اضافه شده در یک پرونده هر ثبت نسبت به ثبت قبلی مقایسه می‌شود و تعداد خطوط اضافه شده جمع زده می‌شود.
\begin{equation} \label{eq:added_line}
ADD = \frac{AddedLines}{AddedLinesInProject}
\end{equation}

	\item
	\textbf{مقدار نرمال‌سازی شده‌ی تعداد خطوط حذف شده:}
\begin{equation} \label{eq:deleted_line}
	DEL = \frac{DeletedLines}{DeletedLinesInProject}
\end{equation}

	\item
	\textbf{درصد خطوطی که مالک پرونده مشارکت کرده:}
	درصد خطوطی  از پرونده، در  ثبت مورد نظر  که به مالک پرونده تعلق دارد. مالک پرونده کسی است که در آن لحظه از زمان بیشترین تعداد خطوط موجود در پرونده به او تعلق دارد. ابتدا نویسنده‌ی هر خط مشخص می‌شود سپس برای هر نویسنده تعداد خطوطی که به وی تعلق دارد شمرده می‌شود. تعداد خطوط مالک پرونده بر تعداد خطوط پرونده تقسیم می‌گردد.
\begin{equation} \label{eq:own}
OWN = \frac{OwnerPatricipation}{LOC} \times 100
\end{equation}

	\item
	\textbf{تعداد ثبت‌های همسایگان:}
	میانگین وزن دهی شده تعداد ثبت‌های همسایگان پرونده از انتشار قبلی تا کنون را اندازه‌گیری می‌کند. همسایگان یک پرونده در یک ثبت، پرونده‌هایی هستند که در آن نسخه از برنامه تغییر کرده‌اند. در‌واقع در هر ثبت از برنامه تعدادی پرونده نسبت به ثبت قبلی تغییر کرده‌اند که این پرونده‌ها همسایه‌ی یکدیگر محسوب می شوند. نحوه‌ی وزن دهی نیز به این صورت است که هرچقدر یک پرونده تعداد دفعات بیشتری را در طول انتشار با پرونده مورد نظر همسایه شده باشد وزن بیشتری می‌یابد. برای محاسبه ابتدا همسایگان پرونده در ثبت  و تعداد دفعاتی که  در طول انتشار همسایه شده‌اند مشخص می‌شوند. سپس برای هر پرونده‌ی همسایه، معیار تعداد ثبت در سیستم کنترل نسخه محاسبه می‌شود. هر معیار در تعداد دفعاتی همسایگی ضرب می‌شود و با هم جمع زده می‌شوند. در انتها بر تعداد کل دفعات همسایگی همسایگان تقسیم می‌شود. 
\begin{equation} \label{eq:ncomm}
NCOMM = \frac{\mathlarger{\sum}\limits_{i=1}^{Neighbors} FON_i \times NCommit_i}{\mathlarger{\sum}\limits_{i=1}^{Neighbors}FON_i}
\end{equation}
	\item
	\textbf{تعداد توسعه‌دهندگان فعال همسایگان:}
	مشابه معیار قبلی عمل می‌شود با این تفاوت که معیار توسعه‌دهندگان فعال در نظر گرفته خواهد شد.
\begin{equation}\label{eq:nadev}
	NADEV = \frac{\mathlarger{\sum}\limits_{i=1}^{Neighbors} FON_i \times NActiveDev_i}{\mathlarger{\sum}\limits_{i=1}^{Neighbors}FON_i}
\end{equation}
	\item
	\textbf{تعداد توسعه‌دهندگان متمایز همسایگان:}
	مشابه معیار قبلی عمل می‌شود با این تفاوت که معیار توسعه‌دهندگان متمایز در نظر گرفته خواهد شد.

\begin{equation} \label{eq:nddev}
NDDEV = \frac{\mathlarger{\sum}\limits_{i=1}^{Neighbors} FON_i \times NDistinctDev_i}{\mathlarger{\sum}\limits_{i=1}^{Neighbors}FON_i}
\end{equation}

	\item
	\textbf{تجربه‌ی تمام مشارکت‌کنندگان:}
	تمام مشارکت‌کنندگان در پرونده تا زمان ثبت مورد نظر یافت می‌شوند. برای هر یک مشابه  اندازه‌ی شماره 5، تجربه محاسبه می‌شود و از مقدار تجربه‌ها میانگین هندسی گرفته می‌شود. 
\begin{equation}\label{eq:aexp}
AEXP = \sqrt[Part]{ \prod\limits_{i=1}^{Part}PCommit_i}
\end{equation}	
	
\end{enumerate}
 
