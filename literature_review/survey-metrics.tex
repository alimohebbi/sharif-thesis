\subsection{معیارهای پیش‌بینی خطا}
\label{subsec:metrics}
معیارهای پیش‌بینی خطا نقش مهمی را در ساخت مدل پیش‌بینی ایفا می‌کنند. اکثریت معیارهای پیش‌بینی خطا را می‌توان به دو دسته‌ی  کلی تقسیم کرد: معیارهای کد و معیارهای فرآیند. معیارهای کد می‌توانند به طور مستقیم از کدهای منبع موجود جمع آوری شوند در حالی که معیارهای فرآیند  از اطلاعات تاریخی که در مخازن نرم‌افزاری مختلف آرشیو شده‌اند استخراج می‌گردند. نمونه‌ای از این مخازن نرم‌افزاری سیستم‌های کنترل نسخه و سیستم‌های ردگیری خطا است. معیار‌های فرآیند از نظر هزینه موثر تر از سایر معیارها هستند\cite{arisholm2010systematic}. در برخی از مقالات نیز معیارهای  پیش‌بینی خطا به سه دسته‌ی: معیارهای کد منبع سنتی، معیارهای شئ‌گرایی و معیارهای فرآیند تقسیم شده‌اند\cite{radjenovic2013software}.\\\\
\textbf{معیارهای کد} \\

معیارهای کد تحت عنوان \واژه{معیارهای محصول} نیز شناخته می‌شوند و میزان پیچیدگی کد را می‌سنجند. \واژه{فرض زمینه‌ای} آنها این است که هرچه کد پیچیده‌تر باشد خطا‌خیز‌تر است. برای اندازه‌گیری پیچیدگی کد پژوهش‌گران معیار‌های مختلفی را ارائه داده‌اند که در ادامه مهم‌ترین آنها معرفی خواهند شد. 

این معیارها با استفاده از اندازه‌های مطرح شده در جدول \ref{tab:measure}  استخراج شده‌اند. 

\begin{table}[H] 
	\renewcommand*{\arraystretch}{1.5}	
	\centering \caption{اندازه‌های به کارگرفته شده  در معیارهای کد }
	\label{tab:measure}
	\newcolumntype{C}{>{\centering\arraybackslash} m } 
	\begin{tabular}{|C{2cm}|C{2cm}|C{1.5cm}|C{8cm}|}
		
		\hline
		\hline
		نام & نام لاتین & علامت اختصاری & توضیح \\
		\hline
		\hline
		تعداد خطوط کد & 		\lr{Line of Code}  & LOC		& این اندازه را می‌توان به اندازه‌های جزیی‌تر مانند تعداد خطوط توضیح، قابل اجرا، خالی از نوشته تقسیم کرد \\
		\hline
		تعداد عملگرها & \lr{Number of Operators} & 
		\lr{$N_1$}
		& تعداد عملگرهای موجود مانند + ، - ، \& \\
		\hline
		 
		تعداد عملوندها&  \lr{Number of Operands} & 
		\lr{$N_2$}
		& تعداد عملوندهای استفاده شده در کنار عملگرها\\
		\hline
			تعداد عملگرهای متمایز & \lr{Number of Unique Operators} & 
		\lr{$\eta_1$}
		& ---\\
		\hline
		
		تعداد عملوندهای متمایز &  \lr{Number of Unique Operands} & 
		\lr{$\eta_2$}
		& ---\\
		\hline
		
تعداد یال‌ها &   \lr{Number of Edges} &  E &  تعداد یال‌های گراف جریان کنترلی\\
		\hline
		تعداد گره‌ها &    \lr{Number of Nodes} & N & تعداد گره‌ها در گراف جریان کنترلی \\
		\hline
		
		تعداد قطعات متصل &    \lr{Number of Connected Component} & P  & تعداد قطعات متصل به هم در گراف جریان کنترلی
		\\
		\hline
		
	\end{tabular}
\end{table}


\begin{itemize}
	\item \textbf{معیار بزرگی: }
معیارهای \واژه{بزرگی} اندازه‌ی کلی و حجم کد را می‌سنجند. یکی از اندازه‌های برجسته که در محاسبه‌ی این معیارها و گاها خود به تنهایی به کار می‌رود "تعداد خطوط" می‌باشد. اولین \نام{آکیاما}{Akiyama}
 \cite{akiyama1971example}  
رابطه‌ی میان خطا و تعداد خطوط را مطرح کرد. \نام{هالستد}{Halstead}
 \cite{halstead1977elements} 
 چندین معیار بزرگی بر اساس  تعداد عملگرها و عملوند‌ها ارائه داده است و در مقاله‌ی \cite{pawade2016exploring} مورد بازنگری قرار گرفته است. معیارهایی که توسط هالستد مطرح شده‌اند در زیر آمده آمده‌اند که با استفاده از اندازه‌های جدول \ref{tab:measure} محاسبه می‌شوند. 
 \begin{latin}
 \baselineskip=1.1cm
Lenght: $N = N_1 + N_2$ \\
Volume: $V = N \times log_2 (\eta_1 + \eta_2)$\\
Difficulty: $D = \eta_1/2 \times N_2/\eta_2$ \\
Effort: $E = D \times V$ \\
Program Time: $T = E/18$ \\
 \end{latin}
 
 
\item \textbf{معیار پیچیدگی حلقوی: }
\نام{مک‌کیب}{McCabe} معیارهای \واژه{پیچیدگی حلقوی}
را پیشنهاد داد که این معیار با استفاده از تعداد گره‌ها، یالها و قطعات متصل در گراف  \واژه{جریان کنترلی} کد منبع محاسبه می‌گردد\cite{mccabe1976complexity}. این معیارها نشان می‌دهند که راه‌های کنترلی به چه میزان پیچیده هستند. باوجود اینکه جز اولین معیارها بوده است همچنان در پیش‌بینی خطا کاربرد دارد \cite{malhotra2014comparative}. این معیار با استفاده با استفاده از فرمول زیر محاسبه می‌شود. 
\begin{latin}
$V(G) = E - N + 2P $
\end{latin}


\item \textbf{معیار مربوط به شئ‌گرایی: }
با ظهور زبان‌های شئ‌گرایی و محبوبیت آنها معیارهای کد  برای این زبان‌ها ارائه شد تا فرآیند توسعه بهبود یابد. نماینده‌ی این معیارها CK می‌باشد که توسط \نام{چدامبر و کمرر}{Chidamber and Kemerer  \lr{(CK)} }
 ارائه شده است\cite{chidamber1994metrics}. این معیارها  که در جدول  \ref{tab:ck-metrics} لیست آنها قرار داده شده، با توجه به خصیصه‌های زبان‌های شئ‌گرا مانند وراثت، \واژه{زوجیت}، \واژه{همبستگی} طراحی شده‌اند. بجز معیارهای  CK، معیارهای شئ‌گرایی دیگری نیز بر اساس حجم و کمیت کد منبع پیشنهاد داده شده‌اند. مشابه معیارهای \موکد{اندازه}، معیارهای شئ‌گرایی تعداد نمونه‌های یک کلاس، توابع را می‌شمارند. \\
 \begin{table}[H] 
 	\renewcommand*{\arraystretch}{1.5}	
 	\centering \caption{معیارهای CK }
 	\label{tab:ck-metrics}
 	\newcolumntype{C}{>{\centering\arraybackslash} m } 
 	\begin{tabular}{|C{2cm}|C{3cm}|C{8cm}|}
 		
 		\hline
 		\hline
 		نام & توضیح & نحوه‌ی محاسبه \\
 		\hline
 		\hline
 		WMC &
 		تعداد توابع وزن‌دهی شده & وزن دهی بر اساس پیچیدگی هر تابع انجام می‌شود \\
 		\hline
DIT & 
عمق درخت وراثت & حداکثر طول مسیر در در از نوادگان یک کلاس تا خود کلاس\\
\hline
NOC &
تعداد فرزندان & تعداد نوادگان مستقیم کلاس\\
\hline
CBO & 
زوجیت میان اشیاء کلاس‌ها & تعداد کلاس‌هایی که کلاس مورد نظر با آن زوج شده‌است. دو کلاس با هم زوجیت دارند اگر یکی از توابع و یا متغر‌های دیگری استفاده کرده باشد. \\
\hline
RFC &
پاسخ برای یک کلاس & تعداد توابعی که با فراخوانی یک تابع از کلاس احتمال فراخوانی دارند. برابر است با تعداد کل توابع کلاس و توابعی از سایر کلاس‌ها که در آنها فراخوانی می‌شوند. \\
\hline
LCOM & 
کمبود همبستگی میان توابع & تعداد جفت توابعی که متغیر مشترک ندارند منهای جفت توابعی که متغیر مشترک دارند. \\
 		
 		\hline

\end{tabular}
\end{table}

\end{itemize}
\textbf{معیارهای فرآیند} \\

در ادامه  تعدادی از معیارهای فرآیند بررسی می‌شوند که در این دسته شاخص محسوب می‌شوند. در جدول \ref{tab:process-measure} اندازه‌هایی که در محاسبه‌ی معیارهای فرآیند به کار گرفته شده‌اند آمده است.
\begin{table}[H] 
	\renewcommand*{\arraystretch}{1.5}	
	\centering \caption{اندازه‌های به کارگرفته شده  در معیارهای فرآیند }
	\label{tab:process-measure}
	\newcolumntype{C}{>{\centering\arraybackslash} m } 
	\begin{tabular}{|C{2cm}|C{2cm}|C{2.25cm}|C{7.25cm}|}
		
		\hline
		\hline
		نام & نام لاتین & علامت اختصاری & توضیح \\
		\hline
		\hline
		تعداد خطوط تبدیلی &  Churned LOC & --- & تعداد خطوط اضافه شده به علاوه‌ی خطوط تغییر داده شده در دو نسخه‌ی متفاوت از برنامه \\
		\hline
		تعداد فایل‌های تبدیلی &
		\lr{Files Churned} & --- &
		تعداد فایل‌های تغییر یافته در یک قطعه \\
		\hline
		تعداد فایل‌ها &
		\lr{Files Count} & --- &
		تعداد فایل‌های موجود در یک قطعه\\
		\hline
		تجدیدنظر‌ها &
		\lr{Revisions} & --- &
		تعداد تجدید نظرهایی (اصلاح‌ها) که در فایل انجام شده است\\
		\hline 
		بازآرایی & 
		Refactoring & --- & 
		تعداد دفعاتی که یک فایل بازآرایی شده است. در واقع تعداد ثبت‌هایی شمرده می‌شود که در توضیح آنها کلمه‌ی refactor وجود داشته باشد.\\
		\hline
		تعداد ایمیل‌ها &
		\lr{Number of Mails} & POP\_NOM &
		 تعداد ایمیل‌هایی که در آنها نام کلاس مورد نظر آورده شده است.\\
		 \hline
		 تعداد نخ‌ها &
		 \lr{Number of Threads} & POP\_NOT &
		 تعداد نخ‌هایی که درباره‌ی یک کلاس صحبت می‌کنند \\
		 \hline
		 تعداد نویسندگان &
		 \lr{ Number of Authors}& POP\_NOA &
		 تعداد نویسندگانی که درباره‌ی کلاس مورد نظر صحبت می‌کنند. \\
		 \hline
	\end{tabular}
\end{table}

\begin{itemize}
\item \textbf{تغییر تبدیلی نسبی کد: }
\نام{ناگاپان و بال}{Nagappan and Ball} هشت معیار تغییر \واژه[تبدیلی]{تبدیل} نسبی کد را ارائه داده‌اند\cite{nagappan2005use}. دو مثال از این معیارها در زیر آمده است.  در معیار $M_1 $ تعداد تجمعی خطوط اضافه و حذف شده بین دو نسخه از برنامه را می‌شمارد و بر تعداد خطوط برنامه تقسیم می‌کند. معیار دیگر تعداد فایل‌های تغییر یافته از یک قطعه برنامه را بر تعداد  کل فایل‌ها تقسیم می‌کند. 
\begin{latin}
$M_1 = Churned LOC / Total LOC$\\
$M_2 = Files Churned / Files Count$
\end{latin}

\item \textbf{معیارهای تغییر: }
این معیارها  گستره‌ی تغییرات در تاریخچه‌ی ذخیره شده در سامانه‌ی کنترل نسخه را اندازه می‌گیرند. به عنوان مثال تعداد رفع خطاها، تعداد \واژه{بازآرایی کد} و یا تعداد نویسندگان یک فایل را می‌شمارند. \نام{موزر}{Moser} و همکاران 18 معیار تغییر را از مخازن \نام{اکلیپس}{Eclipse} استخراج کردند و یک تحلیل مقایسه‌ای میان معیارهای کد و معیارهای تغییر انجام دادند. آنها به این نتیجه رسیدند که معیارهای تغییر پیش‌بینی کننده‌ی بهتری از معیارهای کد هستند.  به عنوان نمونه دو مورد از ۱۸ معیار مطرح شده برابر اندازه‌های \موکد{تجدیدنظر‌ها} و \موکد{بازآرایی} است.

\item \textbf{معیارهای شهرت: }
 \نام{بکچلی}{Bacchelli} و همکاران معیارهای \واژه{شهرت} را بر اساس تحلیل ایمیل‌های آرشیو شده‌ی نویسندگان ارائه داده‌اند. ایده‌ی اصلی این معیارها این است که یک قطعه‌ی  نرم‌افزاری که در ایمیل‌ها درباره‌ی آن بیشتر صحبت شده است خطاخیزتر می‌باشد\cite{bacchelli2010popular}.  بکچلی پنج معیارشهرت معرفی کرده است.  به عنوان نمونه سه مورد از آنها  برابر است با اندازه‌های \موکد{تعداد ایمیل‌ها، تعداد نخ‌ها و تعداد نویسندگان}. \\
\end{itemize}


\نام{راجنویک}{Radjenovic} و همکاران در پژوهش خود به \واژه{بررسی قاعده‌مند} معیارهای پیش‌بینی خطا در مطالعات پیشین پرداخته‌اند.  طبق این پژوهش در 49\lr{\%} مطالعات از معیارهای شئ‌گرایی، در 27\lr{\%} معیارهای سنتی کد و در 26 \lr{\%} از معیارهای فرآیند استفاده شده است. با توجه به مطالعات بررسی شده دقت پیش‌بینی خطا  با انتخاب معیارهای مختلف، تفاوت قابل توجهی  پیدا می‌کند. معیارهای شئ‌گرایی و فرآیند موفق‌تر از معیارهای سنتی هستند. معیارهای سنتی  پیچیدگی کد، قویا با معیارهای اندازه مانند تعداد خطوط کد همبستگی دارند و این دو توانایی پیش‌بینی خطا دارند اما جز بهترین معیارها نیستند. معیارهای شئ‌گرایی بهتر از اندازه و پیچیدگی عمل می‌کنند و با این که با معیارهای اندازه همبستگی دارند اما ویژگی‌های بیشتری علاوه بر اندازه را دارند. معیارهای ایستای کد همانند اندازه، پیچیدگی و شئ‌گرایی به منظور بررسی یک نسخه از برنامه مفید هستند اما با هر \واژه{تکرار} در فرآیند توسعه‌ی نرم‌افزار دقت پیش‌بینی آنها کاسته می‌شوند و معیارهای فرآیند در چنین شرایطی بهتر عمل می‌کنند.  با این وجود  که  معیارهای فرآیند‌  دارای توانمندی بالقوه‌ای  هستند، اما در تعداد کمتری از پژوهش‌ها مورد استفاده قرار گرفته‌اند\cite{radjenovic2013software}. \\
 
\نام{آسترند}{Ostrand} و همکاران به بررسی این موضوع پرداخته‌اند که آیا اطلاعاتی درباره‌ی اینکه کدام توسعه‌دهنده یک فایل را اصلاح می‌کند قادر است که پیش‌بینی خطا را بهبود بخشد. در پژوهش قبلی آنها\cite{weyuker2008too} مشخص شده بود که تعداد کلی   افراد توسعه‌دهنده در یک فایل می‌تواند در پیش‌بینی خطا تاثیر متوسطی داشته باشد. در  مقاله‌ی \cite{ostrand2010programmer}  تعدادی از متغیرهای کد منبع و فرآیند به همراه معیار مرتبط به توسعه‌دهنده در نظر گرفته شده است.  در این پژوهش مشخص شد  که تعداد خطاهایی که یک توسعه‌دهنده تولید می‌کند ثابت است و با سایر توسعه دهندگان فرق دارد. این تفاوت با  حجم کدی که یک توسعه‌دهنده اصلاح می‌کند مرتبط است و در نتیجه در نظر گرفتن یک نویسنده خاص نمی‌تواند به بهبود پیش‌بینی خطا کمک کند\cite{ostrand2010programmer}. \\

\نام{رحمان و دوانبو}{Rahman and Devanbu} از جنبه‌های مختلف معیارهای فرآیند  را با سایر معیارها مقایسه کرده‌اند\cite{rahman2013and}. نتایج نشان می‌دهد  زمانی که مدل پیش‌بینی بر روی یک نسخه آموزش می‌بیند و در نسخه‌ی بعدی آزموده می‌شود معیارهای کد، \lr{AUC} قابل قبولی دارند اما  \lr{AUC}  آنها کمتر از معیارهای فرآیند است  و از نظر معیار 20\% 
\lr{AUCEC} 
بهتر از یک مدل تصادفی عمل نمی‌کنند و  به آن معنی است که این معیارها از نظر هزینه چندان  موثر نیستند. همچنین معیارهای کد ایستاتر هستند، ‌یعنی با تغییرات پروژه و تغییر در توزیع خطاها همچنان معیارها بدون تغییر باقی می‌مانند. معیار ایستا تمایل دارد یک فایل را در \واژه[انتشارهای]{انتشار} متوالی همچنان حاوی خطا معرفی کند. معیارهای ایستا به مدل‌های راکد منجر می‌شوند که این مدل‌ها به سمت فایل‌های بزرگ با تراکم خطای کمتر \واژه{جهت‌گیری} دارند. به عنوان مثال حالتی را در نظر بگیرید که در یک پروژه فایل‌های بزرگ و پیچیده‌ای وجود دارد که پس از چندین انتشار خطاهای آنها برطرف می‌شود اما مدل‌هایی که بر اساس معیارهای کد ساخته شده‌اند همچنان این فایل‌ها را به عنوان خطا‌خیز معرفی می‌کنند. از طرف دیگر حالتی را در نظر بگیرید که یک فایل با اندازه و پیچیدگی کم به تازگی به وجود آمده و یا تغییرات فراوان یافته است. مدل‌های مبتنی بر کد به این فایل‌ها توجه چندانی نخواهند کرد در حالیکه که این فایل‌ها مستعد وجود خطا هستند. بدین ترتیب معیارهای فرآیند بهتر از معیارهای کد عمل می‌کنند. 
 
 
